local log = require "PuRest.Logging.FileLogger"
local LogLevelMap = require "PuRest.Logging.LogLevelMap"
local Process = require "PuRest.Util.System.Process"
local Serialization = require "PuRest.Util.Data.Serialization"
local ServerConfig = require "PuRest.Config.resolveConfig"
local try = require "PuRest.Util.ErrorHandling.try"
local Timer = require "PuRest.Util.Time.Timer"
local Types = require "PuRest.Util.ErrorHandling.Types"
local validateParameters = require "PuRest.Util.ErrorHandling.validateParameters"

local CHECK_PHP_VARS_MSG = "Please check that the phpBinPath value in the server config points to a valid PHP interpreter."

--- Create a command line argument from an value by
-- serializing the value and escaping double quotes.
--
-- @param obj Any lua value.
-- @return A command line parameter which will pass in the lua value as JSON.
--
local function createPhpParameter (value)
    local json = Serialization.serializeToJson(value):gsub([["]], [[\"]])
    return string.format([["%s"]], json)
end

--- Execute a PHP file using the given interpreter binary.
--
-- @param phpBinPath Full path to the PHP interpreter binary.
-- @param absoluteFilename Absolute filename of the PHP script to execute.
-- @param urlArgs URL arguments.
-- @param queryStringArgs Query string arguments.
-- @param requestState Current HTTP request state.
--
-- @return Output from the PHP binary.
--
local function executePhpScript (phpBinPath, absoluteFilename, urlArgs, queryStringArgs, postData, requestState)
	validateParameters(
		{
			phpBinPath = {phpBinPath, Types._string_},
			absoluteFilename = {absoluteFilename, Types._string_}
		})

	local phpInterpreter = Process(phpBinPath, "PHP Interpreter",
		{
			"-f",
			absoluteFilename,
            createPhpParameter(urlArgs),
			createPhpParameter(queryStringArgs),
            createPhpParameter(postData),
            createPhpParameter(requestState),
		})

	return phpInterpreter.run()
end

--- Execute a PHP file inside a site.
--
-- @param filename Relative path to the PHP file to execute.
-- @param siteConfig Config of the site that holds the PHP file.
-- @param urlArgs URL arguments.
-- @param queryStringArgs Query string arguments.
-- @param httpState Current HTTP state.
--
-- @return The text output generated by executing the PHP file.
--
local function renderPhp (filename, siteConfig, urlArgs, queryStringArgs, httpState)
	validateParameters(
		{
			filename = {filename, Types._string_},
			siteConfig = {siteConfig, Types._table_},
		})

	if not ServerConfig.phpBinPath then
		error("Unable to get path for PHP binary. " .. CHECK_PHP_VARS_MSG)
	end

	-- Attempt to execute PHP file.
	local timer = Timer()
	local directory = (siteConfig.fullPath:gsub([[\]], "/")):gsub([[\]], "/")
	local filePath = (string.format("%s/%s", directory, filename)):gsub("//", "/")

    local url = type(urlArgs) == Types._table_ and urlArgs or {}
    local query = type(queryStringArgs) == Types._table_ and queryStringArgs or {}
    local post = type(httpState) == Types._table_ and httpState.request.body or ""

	local phpOut = ""

	try( function ()
		phpOut = executePhpScript(ServerConfig.phpBinPath, filePath,
							      url, query, post,
								  type(httpState) == Types._table_ and httpState.request or {})
	end)
	.catch ( function (ex)
		-- Report any errors during execution.
		error(string.format("Error while rendering PHP script '%s': %s", filePath, ex or "unknown error occurred"))
	end)

	log(string.format("Rendered PHP file '%s' successfully.", filePath), LogLevelMap.INFO)
	log(string.format("Rendering PHP file took %s ms.", timer.endTimeNow()), LogLevelMap.DEBUG)

	return phpOut
end

return renderPhp
